class TestCode(tk.Frame):
    def __init__(self, master, controller, **kwargs):
        super().__init__(master, **kwargs)
        self.controller = controller
        self.base_url = 'https://qdlp2bcmapp0002.ess.fiserv.one/mvcm-api/logs'
        
        # Two-level caching strategy
        self.raw_log_cache = {}  # Cache for raw downloaded logs
        self.filtered_log_cache = {}  # Cache for filtered results
        
        # Track currently viewed log info for header display
        self.current_log_type = None
        self.current_log_name = None
        
        # Main container with horizontal and vertical split
        self.main_container = ttk.PanedWindow(self, orient='horizontal')
        self.main_container.pack(fill='both', expand=True)
        
        # Create left panel for table of contents
        self.toc_frame = ttk.Frame(self.main_container)
        self.main_container.add(self.toc_frame, weight=1)
        
        # Create right panel for log content
        self.content_frame = ttk.Frame(self.main_container)
        self.main_container.add(self.content_frame, weight=4)
        
        # Create an input frame for date and time filters (in the content frame)
        self.input_frame = ttk.Frame(self.content_frame)
        self.input_frame.pack(pady=10, fill='x')
        
        # Date entry label and field
        ttk.Label(self.input_frame, text="Date (YYYY-MM-DD):").grid(row=0, column=0, padx=5, pady=2)
        self.date_entry = ttk.Entry(self.input_frame)
        self.date_entry.grid(row=0, column=1, padx=5, pady=2)
        
        # Time entry label and field
        ttk.Label(self.input_frame, text="Time (HH: or HH:MM):").grid(row=1, column=0, padx=5, pady=2)
        self.time_entry = ttk.Entry(self.input_frame)
        self.time_entry.grid(row=1, column=1, padx=5, pady=2)
        
        # Button to start log retrieval
        self.retrieve_button = ttk.Button(self.input_frame, text="Retrieve Logs", command=self.start_log_retrieval)
        self.retrieve_button.grid(row=2, column=0, columnspan=2, pady=5)
        
        # Add cache status display
        ttk.Label(self.input_frame, text="Cache Status:").grid(row=3, column=0, padx=5, pady=2)
        self.cache_status = ttk.Label(self.input_frame, text="0 logs cached")
        self.cache_status.grid(row=3, column=1, padx=5, pady=2)
        
        # Add clear cache button
        self.clear_cache_button = ttk.Button(self.input_frame, text="Clear Cache", command=self.clear_cache)
        self.clear_cache_button.grid(row=4, column=0, columnspan=2, pady=5)
        
        # Current log position indicator frame
        self.position_frame = ttk.Frame(self.content_frame, relief='ridge', borderwidth=1)
        self.position_frame.pack(fill='x', padx=10, pady=(5, 0))
        
        self.position_label = ttk.Label(self.position_frame, text="No log selected", anchor='w', font=("Verdana", 9, "bold"))
        self.position_label.pack(fill='x', padx=5, pady=2)
        
        # Create a panel for displaying logs
        self.log_panel = ttk.Frame(self.content_frame)
        self.log_panel.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Create Text widget with both horizontal and vertical scrollbars
        self.text_widget = tk.Text(self.log_panel, wrap='none', font=("Verdana", 10))
        self.text_widget.pack(side='left', fill='both', expand=True)
        
        # Create a vertical scrollbar and attach it
        self.v_scrollbar = ttk.Scrollbar(self.log_panel, orient='vertical', command=self.text_widget.yview)
        self.v_scrollbar.pack(side='right', fill='y')
        self.text_widget.configure(yscrollcommand=self.v_scrollbar.set)
        
        # Create a horizontal scrollbar and attach it
        self.h_scrollbar = ttk.Scrollbar(self.log_panel, orient='horizontal', command=self.text_widget.xview)
        self.h_scrollbar.pack(side='bottom', fill='x')
        self.text_widget.configure(xscrollcommand=self.h_scrollbar.set)
        
        # Bind scroll event to update position indicator
        self.text_widget.bind("<<Modified>>", self.update_position_indicator)
        self.text_widget.bind("<KeyRelease>", self.update_position_indicator)
        self.text_widget.bind("<ButtonRelease-1>", self.update_position_indicator)
        
        # Table of Contents setup
        self.toc_label = ttk.Label(self.toc_frame, text="Log Types", font=("Verdana", 11, "bold"))
        self.toc_label.pack(pady=10, padx=5, anchor='w')
        
        # Treeview for table of contents
        self.toc_tree = ttk.Treeview(self.toc_frame, show="tree")
        self.toc_tree.pack(fill='both', expand=True, padx=5, pady=5)
        self.toc_tree.bind("<<TreeviewSelect>>", self.on_toc_select)
        
        # Dictionary to keep track of log entries by type
        self.log_entries = {}

    def start_log_retrieval(self):
        """Initiates the log retrieval process based on date and time inputs."""
        # Get date and time from entry fields
        date_str = self.date_entry.get().strip()
        time_str = self.time_entry.get().strip()
        
        # Validate inputs
        if not date_str:
            tk.messagebox.showerror("Error", "Date is required.")
            return
        
        # Clear previous logs from display
        self.text_widget.delete(1.0, tk.END)
        
        # Show loading indicator
        self.retrieve_button.config(state='disabled', text="Loading...")
        self.update()
        
        # Start retrieval in a separate thread to keep UI responsive
        threading.Thread(target=self.retrieve_logs, args=(date_str, time_str), daemon=True).start()

    def retrieve_logs(self, date_str, time_str):
        """Retrieves logs from the server or cache."""
        # Logic for retrieving logs (kept the same)
        # ...
        
        # After retrieving logs, organize them by type
        self.organize_logs_by_type(logs)
        
        # Re-enable button
        self.retrieve_button.config(state='normal', text="Retrieve Logs")

    def organize_logs_by_type(self, logs):
        """Organizes logs by their type and populates the table of contents."""
        # Clear existing items in treeview
        for item in self.toc_tree.get_children():
            self.toc_tree.delete(item)
        
        self.log_entries = {}
        
        # Group logs by type
        for log in logs:
            log_type = log.get('type', 'Unknown')
            if log_type not in self.log_entries:
                self.log_entries[log_type] = []
                
                # Add log type as parent in treeview
                parent_id = self.toc_tree.insert('', 'end', text=log_type, open=False)
                
            # Add log entry to the list for this type
            self.log_entries[log_type].append(log)
            
            # Add log entry as child in treeview under its type
            log_name = log.get('name', 'Unnamed Log')
            self.toc_tree.insert(parent_id, 'end', text=log_name, values=(log_type, log_name))

    def on_toc_select(self, event):
        """Handles selection in the table of contents."""
        selected_item = self.toc_tree.selection()[0]
        parent = self.toc_tree.parent(selected_item)
        
        if parent:  # This is a log entry (child)
            log_type, log_name = self.toc_tree.item(selected_item, 'values')
            self.display_log(log_type, log_name)
        else:  # This is a log type (parent)
            log_type = self.toc_tree.item(selected_item, 'text')
            # Expand/collapse the node
            if self.toc_tree.item(selected_item, 'open'):
                self.toc_tree.item(selected_item, open=False)
            else:
                self.toc_tree.item(selected_item, open=True)

    def display_log(self, log_type, log_name):
        """Displays the selected log content."""
        # Update current log tracking
        self.current_log_type = log_type
        self.current_log_name = log_name
        
        # Find the log in our cached entries
        log_content = None
        for log in self.log_entries.get(log_type, []):
            if log.get('name') == log_name:
                log_content = log.get('content', 'No content available')
                break
        
        # Display log content
        self.text_widget.delete(1.0, tk.END)
        if log_content:
            self.text_widget.insert(tk.END, log_content)
        else:
            self.text_widget.insert(tk.END, f"No content found for {log_name}")
        
        # Update position indicator
        self.update_position_indicator()
        
        # Reset the modified flag
        self.text_widget.edit_modified(False)

    def update_position_indicator(self, event=None):
        """Updates the position indicator showing current log info."""
        if self.current_log_type and self.current_log_name:
            # Get current line number
            current_pos = self.text_widget.index(tk.INSERT)
            line, column = current_pos.split('.')
            
            # Update the position indicator
            self.position_label.config(
                text=f"{self.current_log_type} > {self.current_log_name} (Line: {line})"
            )
        
        # Reset the modified flag if this was called due to a <<Modified>> event
        if event and event.widget.edit_modified():
            event.widget.edit_modified(False)

    def clear_cache(self):
        """Clears the log cache."""
        self.raw_log_cache = {}
        self.filtered_log_cache = {}
        self.cache_status.config(text="0 logs cached")
        tk.messagebox.showinfo("Cache Cleared", "Log cache has been cleared.")
