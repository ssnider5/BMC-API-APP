import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import queue

class CreateFromExcelPanel(tk.Frame):
    def __init__(self, master, excel_parser, mvcm_inst, **kwargs):
        super().__init__(master, **kwargs)
        self.excel_parser = excel_parser
        self.selected_file = None
        self.create_widgets()
        self.mvcm_inst = mvcm_inst
        self.created_servers = []  # To store names of created servers
        self.verification_results = {}  # Store verification results for each server
        self.notification_showing = False
        self.colors_defined = False  # Track if colors have been defined
        
        # This will map server_name -> Treeview item ID for quick color updates
        self.server_item_map = {}

    def create_widgets(self):
        # Main container
        container = ttk.Frame(self)
        container.pack(fill=tk.BOTH, expand=True)
        
        # File selection frame
        file_frame = ttk.Frame(container)
        file_frame.pack(fill=tk.X, pady=(10, 20))
        
        # File path display
        self.file_path_var = tk.StringVar()
        self.file_path_var.set("No file selected")
        file_path_label = ttk.Label(file_frame, text="Excel File:")
        file_path_label.pack(side=tk.LEFT, padx=5)
        file_path_entry = ttk.Entry(file_frame, textvariable=self.file_path_var, width=50, state='readonly')
        file_path_entry.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        # Browse button
        browse_button = ttk.Button(file_frame, text="Browse...", command=self.browse_file)
        browse_button.pack(side=tk.LEFT, padx=5)
        
        # Table frame
        self.table_frame = ttk.Frame(container)
        self.table_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Initially empty message
        self.empty_label = ttk.Label(self.table_frame, text="Select an Excel file to display data")
        self.empty_label.pack(expand=True)
        
        # Actions frame
        actions_frame = ttk.Frame(container)
        actions_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Import button (initially disabled)
        self.import_button = ttk.Button(actions_frame, text="Create CCS servers", command=self.import_data, state='disabled')
        self.import_button.pack(side=tk.BOTTOM, pady=10)
        
        # Status bar for notifications
        self.status_frame = ttk.Frame(self)
        self.status_frame.pack(fill=tk.X, side=tk.BOTTOM)
        
        # Create notification widget (initially hidden)
        self.notification_frame = ttk.Frame(self.master, relief="raised", borderwidth=2)
        self.notification_label = ttk.Label(self.notification_frame, text="", wraplength=300)
        self.notification_label.pack(padx=10, pady=10)
        self.close_button = ttk.Button(self.notification_frame, text="×", width=2, 
                                       command=self.hide_notification)
        self.close_button.pack(side=tk.RIGHT, anchor=tk.NE, padx=5, pady=5)

    def hide_notification(self):
        """Hide the notification popup"""
        self.notification_frame.place_forget()
        self.notification_showing = False

    def show_notification(self, message, error=False):
        """Show a notification popup in the bottom right corner"""
        # Configure notification appearance
        if error:
            self.notification_label.config(foreground="red")
        else:
            self.notification_label.config(foreground="black")
        
        # Update message
        self.notification_label.config(text=message)
        
        # Calculate position (bottom right)
        window_width = self.master.winfo_width()
        window_height = self.master.winfo_height()
        notification_width = 320  # Fixed width for notification
        notification_height = 100  # Approximate height
        
        x_position = window_width - notification_width - 20
        y_position = window_height - notification_height - 20
        
        # Show notification
        self.notification_frame.place(x=x_position, y=y_position, width=notification_width)
        self.notification_showing = True
        
        # Auto-hide after 5 seconds
        self.after(5000, self.hide_notification)

    def browse_file(self):
        file_path = filedialog.askopenfilename(
            title="Select Excel File",
            filetypes=[("Excel files", "*.xlsx *.xls")]
        )
        
        if file_path:
            self.selected_file = file_path
            self.file_path_var.set(file_path)
            self.load_excel_preview()
    
    def load_excel_preview(self):
        # Clear existing table if any
        for widget in self.table_frame.winfo_children():
            widget.destroy()
        
        try:
            # Use the excel parser to read the file
            headers, data = self.excel_parser.read_excel(self.selected_file)
            
            # Create new treeview for the data
            self.data_tree = ttk.Treeview(self.table_frame, columns=headers, show='headings')
            
            # Define tag colors immediately after creating the treeview
            self.data_tree.tag_configure('success', background='#90EE90')  # Light green
            self.data_tree.tag_configure('failure', background='#FFCCCB')  # Light red
            self.colors_defined = True
            
            # Set column headings
            for header in headers:
                self.data_tree.heading(header, text=header)
                # Adjust column width based on content
                self.data_tree.column(header, width=100)
            
            # Insert data rows
            self.server_item_map = {}  # Reset mapping
            for row in data:
                item_id = self.data_tree.insert("", tk.END, values=row)
                # For convenience, assume the server name is in row[0] or row[3], etc.
                # Adjust as needed:
                if len(row) > 0:
                    server_name = row[0]  # or row[3] if that’s where server is
                    self.server_item_map[server_name] = item_id
            
            # Add scrollbars
            y_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.VERTICAL, command=self.data_tree.yview)
            self.data_tree.configure(yscrollcommand=y_scrollbar.set)
            
            x_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL, command=self.data_tree.xview)
            self.data_tree.configure(xscrollcommand=x_scrollbar.set)
            
            # Pack everything in the right order
            x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.data_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # Bind selection event to show details
            self.data_tree.bind("<<TreeviewSelect>>", self.on_tree_select)
            
            # Enable import button
            self.import_button.config(state='normal')
            
        except Exception as e:
            error_label = ttk.Label(self.table_frame, text=f"Error loading Excel file: {str(e)}", foreground="red")
            error_label.pack(expand=True)   
            self.import_button.config(state='disabled')
    
    def on_tree_select(self, event):
        """Handle selection of a row in the treeview"""
        selected_items = self.data_tree.selection()
        if not selected_items:
            return
            
        item_values = self.data_tree.item(selected_items[0], "values")
        if not item_values:
            return
            
        # Adjust index based on your actual data structure
        server_name = item_values[0]
        
        # Check if we have verification results for this server
        if server_name in self.verification_results:
            result = self.verification_results[server_name]
            if result.get('error'):
                self.show_notification(f"Error for {server_name}: {result['error_code']}", error=True)
    
    def import_data(self):
        try:
            json_data = self.excel_parser.get_json_data()
            self.created_servers = self.excel_parser.extract_names(json_data)
            _result = self.excel_parser.create_ccs_server(self.mvcm_inst, json_data)
            
            messagebox.showinfo("Import Successful", "Data has been successfully imported!")
            self.show_verification_prompt()
            
        except Exception as e:
            messagebox.showerror("Import Failed", f"Failed to import data: {str(e)}")

    def show_verification_prompt(self):
        """Shows a popup asking if the user wants to verify the servers"""
        verify = messagebox.askyesno("Verify Servers", "Would you like to verify the server(s)?")
        if verify:
            self.verify_import()

    def verify_import(self):
        """Verifies the imported servers by sending POST requests in parallel."""
        if not self.created_servers:
            messagebox.showinfo("Verification", "No servers to verify.")
            return

        # Reset verification results
        self.verification_results = {}

        # Create a small progress window that will remain open while threads run
        progress_window = tk.Toplevel(self)
        progress_window.title("Verifying Servers")
        progress_window.geometry("300x100")
        progress_window.transient(self)
        progress_window.grab_set()
        
        progress_label = ttk.Label(progress_window, text="Verifying servers...")
        progress_label.pack(pady=10)
        
        progress = ttk.Progressbar(progress_window, length=250, mode='determinate')
        progress.pack(pady=10)
        progress['maximum'] = len(self.created_servers)
        
        # We’ll use a queue to get results from worker threads
        result_queue = queue.Queue()

        def verify_one_server(server_name):
            """
            This function runs in a worker thread.
            It returns a dict with all relevant info
            needed to update the UI.
            """
            try:
                endpoint = f"/api/ccs/servers/{server_name}/operations/start"
                _response = self.mvcm_inst.post(endpoint)  # start the server

                r = self.mvcm_inst.getlog(server_name)
                log_text = r.text
                lines = log_text.splitlines()

                is_success = False
                if len(lines) >= 3:
                    third_to_last_line = lines[-3]
                    if "Error exit" in third_to_last_line:
                        is_success = False
                    else:
                        is_success = True

                return {
                    'server_name': server_name,
                    'success': is_success,
                    'error': not is_success,
                    'error_code': 'fail' if not is_success else ''
                }
            except Exception as e:
                return {
                    'server_name': server_name,
                    'success': False,
                    'error': True,
                    'error_code': str(e)
                }

        def worker_done(future):
            """
            Called when a single future completes (in the main thread).
            We pull the result, push it into the queue for UI updates.
            """
            res = future.result()
            result_queue.put(res)

        # Create a thread pool
        executor = ThreadPoolExecutor(max_workers=5)

        # Submit tasks
        futures = []
        for server_name in self.created_servers:
            # skip empty
            if not server_name:
                continue
            future = executor.submit(verify_one_server, server_name)
            future.add_done_callback(worker_done)
            futures.append(future)

        # Track how many servers have finished
        finished_count = [0]  # put in a list so we can modify inside the function

        def process_results():
            """
            Periodically called in the main thread (via self.after).
            We check for completed results in the queue and update the GUI.
            """
            while not result_queue.empty():
                res = result_queue.get_nowait()
                server_name = res['server_name']
                self.verification_results[server_name] = res

                # Bump progress
                finished_count[0] += 1
                progress['value'] = finished_count[0]
                progress_label.config(text=f"Verifying {server_name}...")

                # Update the corresponding row color
                # Make sure color tags are defined
                if not self.colors_defined:
                    self.data_tree.tag_configure('success', background='#90EE90')
                    self.data_tree.tag_configure('failure', background='#FFCCCB')
                    self.colors_defined = True

                if server_name in self.server_item_map:
                    item_id = self.server_item_map[server_name]
                    # Clear existing tags
                    current_tags = list(self.data_tree.item(item_id, "tags"))
                    if 'success' in current_tags:
                        current_tags.remove('success')
                    if 'failure' in current_tags:
                        current_tags.remove('failure')
                    # Add success/failure
                    new_tag = 'success' if res['success'] else 'failure'
                    current_tags.append(new_tag)
                    self.data_tree.item(item_id, tags=current_tags)

            # If all futures are done, finalize. Otherwise, check again.
            if all(f.done() for f in futures):
                # Close the executor
                executor.shutdown(wait=False)
                # Close progress window
                progress_window.destroy()
                # Show summary
                success_count = sum(1 for v in self.verification_results.values() if v['success'])
                failure_count = len(self.verification_results) - success_count
                messagebox.showinfo(
                    "Verification Complete",
                    f"Verification complete.\nSuccessful: {success_count}\nFailed: {failure_count}\n\n"
                    f"Select a server in the table for error details."
                )
            else:
                # Not all done; schedule another check
                self.after(200, process_results)

        # Start checking results
        self.after(200, process_results)
