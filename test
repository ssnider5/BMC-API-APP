# -------------------------------
# Excel Upload Panel
# -------------------------------
class ExcelUploadPanel(tk.Frame):
    def __init__(self, master, on_excel_selected, **kwargs):
        super().__init__(master, **kwargs)
        self.on_excel_selected = on_excel_selected
        self.excel_data = None
        self.headers = []
        self.create_widgets()

    def create_widgets(self):
        # Main container frame
        main_frame = ttk.Frame(self)
        main_frame.pack(fill=tk.BOTH, expand=True, pady=20)
        
        # File selection frame
        file_frame = ttk.Frame(main_frame)
        file_frame.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(file_frame, text="Select Excel File:").pack(side=tk.LEFT, padx=(0, 10))
        
        self.file_path = tk.StringVar()
        self.file_entry = ttk.Entry(file_frame, textvariable=self.file_path, width=60)
        self.file_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        browse_button = ttk.Button(file_frame, text="Browse", command=self.browse_file)
        browse_button.pack(side=tk.LEFT)
        
        # Table container for displaying Excel data
        table_container = ttk.LabelFrame(main_frame, text="Excel Content Preview")
        table_container.pack(fill=tk.BOTH, expand=True, pady=(10, 0))

        # Add a frame for the table with scrollbars
        table_frame = ttk.Frame(table_container)
        table_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Create scrollbars
        x_scrollbar = ttk.Scrollbar(table_frame, orient=tk.HORIZONTAL)
        y_scrollbar = ttk.Scrollbar(table_frame, orient=tk.VERTICAL)
        
        # Create Treeview widget for the table
        self.table = ttk.Treeview(table_frame, 
                                  xscrollcommand=x_scrollbar.set,
                                  yscrollcommand=y_scrollbar.set)
        
        # Configure scrollbars
        x_scrollbar.config(command=self.table.xview)
        y_scrollbar.config(command=self.table.yview)
        
        # Grid layout for table and scrollbars
        self.table.grid(row=0, column=0, sticky="nsew")
        y_scrollbar.grid(row=0, column=1, sticky="ns")
        x_scrollbar.grid(row=1, column=0, sticky="ew")
        
        # Configure grid weights
        table_frame.grid_rowconfigure(0, weight=1)
        table_frame.grid_columnconfigure(0, weight=1)
        
        # Configure initial table state
        self.table["show"] = "headings"  # Hide the default empty first column

        # Status label
        self.status_var = tk.StringVar()
        self.status_var.set("No file selected")
        status_label = ttk.Label(main_frame, textvariable=self.status_var, foreground="gray")
        status_label.pack(fill=tk.X, pady=(10, 0))
        
        # Set up the file path change callback
        self.file_path.trace('w', self.on_file_path_change)
        
    def browse_file(self):
        filename = filedialog.askopenfilename(
            title="Select an Excel file", 
            filetypes=[("Excel files", "*.xlsx *.xls"), ("All files", "*.*")])
        if filename:
            self.file_path.set(filename)
            
    def on_file_path_change(self, *args):
        file_path = self.file_path.get()
        if file_path and (file_path.endswith('.xlsx') or file_path.endswith('.xls')):
            self.status_var.set(f"Loading {os.path.basename(file_path)}...")
            self.after(100, lambda: self.parse_excel(file_path))
        elif file_path:
            self.status_var.set("Not a valid Excel file")
    
    def parse_excel(self, file_path):
        try:
            # Clear the existing table
            for column in self.table["columns"]:
                self.table.heading(column, text="")
            self.table["columns"] = ()
            for item in self.table.get_children():
                self.table.delete(item)
            
            # Parse Excel file using ExcelParser class
            parser = ExcelParser(file_path)
            self.excel_data = parser.get_data()
            self.headers = parser.get_headers()
            
            # Update the table with headers
            self.table["columns"] = self.headers
            
            # Set column headings
            for header in self.headers:
                self.table.heading(header, text=header)
                self.table.column(header, minwidth=100, width=150)
            
            # Insert data rows
            for row in self.excel_data[:100]:  # Limit to 100 rows for performance
                values = [row.get(header, "") for header in self.headers]
                self.table.insert("", tk.END, values=values)
            
            # Call the callback with the file path
            if self.on_excel_selected:
                self.on_excel_selected(file_path, self.headers, self.excel_data)
            
            row_count = len(self.excel_data)
            self.status_var.set(f"Loaded {os.path.basename(file_path)} - {row_count} rows, {len(self.headers)} columns")
            
        except Exception as e:
            self.status_var.set(f"Error loading file: {str(e)}")
            messagebox.showerror("Error", f"Failed to load Excel file: {str(e)}")


# -------------------------------
# Excel Parser Class
# -------------------------------
class ExcelParser:
    def __init__(self, file_path):
        self.file_path = file_path
        self.data = []
        self.headers = []
        self._parse()
    
    def _parse(self):
        try:
            import pandas as pd
            # Read Excel file
            df = pd.read_excel(self.file_path)
            
            # Convert to list of dictionaries
            self.data = df.to_dict('records')
            
            # Get headers
            self.headers = list(df.columns)
        except ImportError:
            # Fallback if pandas is not available
            try:
                import openpyxl
                wb = openpyxl.load_workbook(self.file_path, read_only=True)
                sheet = wb.active
                
                # Get headers from first row
                self.headers = [cell.value for cell in next(sheet.rows)]
                
                # Process data rows
                for row in list(sheet.rows)[1:]:
                    row_data = {}
                    for i, cell in enumerate(row):
                        if i < len(self.headers) and self.headers[i]:
                            row_data[self.headers[i]] = cell.value
                    self.data.append(row_data)
            except ImportError:
                # If both pandas and openpyxl are not available
                raise Exception("Required libraries (pandas or openpyxl) not found")
    
    def get_data(self):
        return self.data
    
    def get_headers(self):
        return self.headers


# Update the ActionPanel class to handle the "Create from Excel" option
def show_panel(self, action):
    self.current_action = action
    # Update button colors in side panel: set the active button to orange, others to default
    for act, button in self.side_panel_buttons.items():
        if act == action:
            button.config(bg="#FF8C00", activebackground="#FF8C00", fg="white")
        else:
            button.config(bg="#444444", activebackground="#555555", fg="white")

    # Clear any existing panel from the panel container and button frame
    for widget in self.panel_container.winfo_children():
        widget.destroy()
    for widget in self.button_frame.winfo_children():
        widget.destroy()

    if action in ['Download', 'Restore']:
        panel = DownloadRestorePanel(self.panel_container, action, self.saved_configs,
                                    self.username, self.controller.mvcm, self.on_config_select)
        panel.pack(fill=tk.BOTH, expand=True)
        panel.refresh_configs()
    elif action == 'Upload':
        panel = UploadPanel(self.panel_container, self.on_file_select)
        panel.pack(fill=tk.BOTH, expand=True)
    elif action == 'Create':
        panel = CreatePanel(self.panel_container, self.on_create)
        panel.pack(fill=tk.BOTH, expand=True)
    elif action == 'Update':
        panel = UpdatePanel(self.panel_container, self.servers, self.on_update_select)
        panel.pack(fill=tk.BOTH, expand=True)
    elif action == 'Create from Excel':
        panel = ExcelUploadPanel(self.panel_container, self.on_excel_select)
        panel.pack(fill=tk.BOTH, expand=True)

    # Add the process button
    process_button = tk.Button(self.button_frame, text=action, command=self.process_action)
    process_button.pack(pady=10)
    
    self.master.bind('<Return>', lambda e: self.process_action())

# Add the following methods to the ActionPanel class

def on_excel_select(self, file_path, headers, data):
    """Callback when an Excel file is selected and parsed."""
    self.selected_excel_file = file_path
    self.excel_headers = headers
    self.excel_data = data
    print(f"Excel file selected: {file_path}")
    print(f"Headers: {headers[:5]}..." if len(headers) > 5 else f"Headers: {headers}")
    print(f"Loaded {len(data)} rows of data")

# Update the process_action method to handle 'Create from Excel'
def process_action(self):
    action = self.current_action
    if action == 'Download' and self.selected_config_name:
        # Existing code...
    elif action == 'Restore' and self.selected_config_name:
        # Existing code...
    elif action == 'Upload' and self.selected_file:
        # Existing code...
    elif action == 'Create' and self.create_data:
        # Existing code...
    elif action == 'Update' and self.source_hostname and self.target_hostname:
        # Existing code...
    elif action == 'Create from Excel' and hasattr(self, 'selected_excel_file'):
        self.process_create_from_excel()
    else:
        print("Required selections are missing for the chosen action.")

def process_create_from_excel(self):
    """Process the 'Create from Excel' action."""
    try:
        # Here you would implement the logic to process the Excel data
        # This would typically involve calling a method on the controller
        success = self.controller.create_from_excel(
            self.selected_excel_file,
            self.excel_headers,
            self.excel_data
        )
        
        if success:
            messagebox.showinfo("Success", "Configuration created successfully from Excel data!")
        else:
            messagebox.showerror("Error", "Failed to create configuration from Excel.")
            
    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {str(e)}")
