import tkinter as tk
from tkinter import ttk
from datetime import datetime
import threading
import json
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor

class TestCode(tk.Frame):
    def __init__(self, master, controller, username, password, servers, **kwargs):
        super().__init__(master, **kwargs)
        self.controller = controller
        self.username = username
        self.password = password
        self.servers = servers  # List of tuples: (Environment, Hostname)
        self.selected_server = self.servers[0]

        # Create an input frame for date and time filters.
        self.input_frame = ttk.Frame(self)
        self.input_frame.pack(pady=10)
        
        # Date entry label and field.
        ttk.Label(self.input_frame, text="Date (YYYY-MM-DD):").grid(row=0, column=0, padx=5, pady=2)
        self.date_entry = ttk.Entry(self.input_frame)
        self.date_entry.grid(row=0, column=1, padx=5, pady=2)
        
        # Time entry label and field.
        ttk.Label(self.input_frame, text="Time (HH: or HH:MM):").grid(row=1, column=0, padx=5, pady=2)
        self.time_entry = ttk.Entry(self.input_frame)
        self.time_entry.grid(row=1, column=1, padx=5, pady=2)
        
        # Button to start log retrieval.
        self.retrieve_button = ttk.Button(self.input_frame, text="Retrieve Logs", command=self.start_log_retrieval)
        self.retrieve_button.grid(row=2, column=0, columnspan=2, pady=5)

        # Create a panel for displaying logs.
        self.log_panel = ttk.Frame(self)
        self.log_panel.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Create the Text widget for log output.
        self.text_widget = tk.Text(self.log_panel, wrap='none', font=("Courier", 10))
        self.text_widget.pack(side='left', fill='both', expand=True)
        
        # Create a vertical scrollbar and attach it.
        self.v_scrollbar = ttk.Scrollbar(self.log_panel, orient='vertical', command=self.text_widget.yview)
        self.v_scrollbar.pack(side='right', fill='y')
        self.text_widget.configure(yscrollcommand=self.v_scrollbar.set)
    
    def start_log_retrieval(self):
        """Starts a background thread to retrieve logs based on the entered date and time filters."""
        date_filter = self.date_entry.get().strip()
        time_filter = self.time_entry.get().strip()
        
        # If fields are empty, use None so that no filtering is applied.
        if date_filter == "":
            date_filter = None
        if time_filter == "":
            time_filter = None

        # Start a background thread so the UI remains responsive.
        retrieval_thread = threading.Thread(target=self.testCode, args=(date_filter, time_filter))
        retrieval_thread.daemon = True
        retrieval_thread.start()
    
    def download_and_filter_log(self, base_url, package_index, parent, name, time_filter):
        """
        Downloads a single log file and applies time filtering if specified.
        Constructs the download URL based on the presence of a parent.
        """
        if parent and not (name.startswith('server.') and name.endswith('.log') and name[7:-4].isdigit()) and not (name.startswith('catalina.')):
            download_url = f'{base_url}/download/{package_index}/{parent}/{name}'
        else:
            download_url = f'{base_url}/download/{package_index}/{name}'
        
        download_resp = self.controller.mvcm.getalllogs(download_url)
        log_content = download_resp.text if hasattr(download_resp, 'text') else download_resp
        
        # If a time filter is specified, filter the log lines.
        if time_filter:
            filtered_lines = []
            desired_hour = time_filter.split(":")[0]
            for line in log_content.splitlines():
                # Assume a log line begins with a timestamp "YYYY-MM-DD HH:MM:SS"
                if len(line) >= 13:
                    log_hour = line[11:13]
                    if log_hour == desired_hour:
                        filtered_lines.append(line)
                else:
                    filtered_lines.append(line)
            log_content = "\n".join(filtered_lines)
        
        return log_content

    def testCode(self, specified_date=None, specified_time=None):
        """
        Retrieve log files from the API with optional date and time filtering.
        
        - Only process logs modified on or after the specified_date (if provided).
        - Uses a thread pool to concurrently download log files.
        - If a time filter is specified (e.g. "17:" or "17:30"), the log content is filtered to include only lines
          where the hour matches the specified hour.
        """
        # If no date is provided, set a very early date.
        if specified_date:
            date_filter = specified_date
        else:
            date_filter = "0000-00-00"
        
        time_filter = specified_time if specified_time else ""
        
        log_files = {}
        base_url = 'https://qdlp2bcmapp0002.ess.fiserv.one/mvcm-api/logs'
        resp = self.controller.mvcm.getalllogs(base_url)
        try:
            packages = resp.json()
        except Exception:
            packages = json.loads(resp.text)
        
        # Use ThreadPoolExecutor to parallelize the API calls for downloading logs.
        with ThreadPoolExecutor(max_workers=5) as executor:
            future_to_log = {}
            for i, package in enumerate(packages, 1):
                log_type = package.get('name', 'Unknown')
                resp = self.controller.mvcm.getalllogs(f'{base_url}/{i}')
                log_files_array = resp.json().get('logFiles', [])
                for log_file in log_files_array:
                    name = log_file.get('name', 'Unnamed Log')
                    parent = log_file.get('parent')
                    date_modified = log_file.get('dateModified')
                    
                    # Only process logs modified on or after the specified date.
                    if date_modified and date_modified >= date_filter:
                        # Submit the download task to the thread pool.
                        future = executor.submit(self.download_and_filter_log, base_url, i, parent, name, time_filter)
                        future_to_log[future] = (name, log_type)
            
            # Collect results as they complete.
            for future in concurrent.futures.as_completed(future_to_log):
                name, log_type = future_to_log[future]
                try:
                    log_content = future.result()
                except Exception as exc:
                    log_content = f"Error retrieving log: {exc}"
                log_files[name] = {'type': log_type, 'content': log_content}
        
        # Schedule the UI update on the main thread.
        self.text_widget.after(0, self.update_text_widget, log_files)
    
    def update_text_widget(self, log_files):
        """Update the Text widget with the retrieved logs."""
        self.text_widget.delete("1.0", tk.END)
        self.text_widget.insert(tk.END, "Collected Log Files:\n")
        self.text_widget.insert(tk.END, "=" * 80 + "\n")
        for log_name, details in log_files.items():
            self.text_widget.insert(tk.END, f"Log Name: {log_name}\n")
            self.text_widget.insert(tk.END, f"Log Type: {details['type']}\n")
            self.text_widget.insert(tk.END, "-" * 80 + "\n")
            self.text_widget.insert(tk.END, details['content'] + "\n")
            self.text_widget.insert(tk.END, "=" * 80 + "\n")
